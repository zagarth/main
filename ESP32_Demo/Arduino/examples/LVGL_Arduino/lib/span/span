#ifndef STD_SPAN_POLYFILL_H
#define STD_SPAN_POLYFILL_H

#include <cstddef>
#include <type_traits>
#include <iterator>

namespace std {

template<typename T>
class span {
public:
    using element_type = T;
    using value_type = typename std::remove_cv<T>::type;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using iterator = pointer;
    using const_iterator = const_pointer;

    constexpr span() noexcept : data_(nullptr), size_(0) {}
    
    constexpr span(pointer ptr, size_type count) noexcept 
        : data_(ptr), size_(count) {}
    
    template<size_t N>
    constexpr span(element_type (&arr)[N]) noexcept 
        : data_(arr), size_(N) {}
    
    constexpr pointer data() const noexcept { return data_; }
    constexpr size_type size() const noexcept { return size_; }
    constexpr size_type size_bytes() const noexcept { return size_ * sizeof(element_type); }
    constexpr bool empty() const noexcept { return size_ == 0; }
    
    constexpr reference operator[](size_type idx) const { return data_[idx]; }
    constexpr reference front() const { return data_[0]; }
    constexpr reference back() const { return data_[size_ - 1]; }
    
    constexpr iterator begin() const noexcept { return data_; }
    constexpr iterator end() const noexcept { return data_ + size_; }
    constexpr const_iterator cbegin() const noexcept { return data_; }
    constexpr const_iterator cend() const noexcept { return data_ + size_; }

    constexpr span<element_type> first(size_type count) const {
        return span<element_type>(data_, count);
    }

    constexpr span<element_type> last(size_type count) const {
        return span<element_type>(data_ + (size_ - count), count);
    }

    constexpr span<element_type> subspan(size_type offset, size_type count = size_type(-1)) const {
        return span<element_type>(data_ + offset, 
            count == size_type(-1) ? size_ - offset : count);
    }

private:
    pointer data_;
    size_type size_;
};

} // namespace std

#endif // STD_SPAN_POLYFILL_H
